# Clockworks

Clockworks is a .NET library for deterministic, fully controllable time in distributed-system simulations and tests.
It is built around `TimeProvider` so that *time becomes an injectable dependency* you can control (including timers/timeouts), while also providing time-ordered identifiers and causal timestamps.

## Features

- **Deterministic `TimeProvider`**
  - `SimulatedTimeProvider` with controllable wall time (`SetUtcNow`, etc.)
  - Monotonic scheduler time that advances only via `Advance(...)`
  - Deterministic timer ordering and predictable periodic behavior

- **`TimeProvider`-driven timeouts**
  - `Timeouts.CreateTimeout(...)` for a `CancellationTokenSource` cancelled by the provider
  - `Timeouts.CreateTimeoutHandle(...)` for a disposable handle that ties timer lifetime to disposal

- **UUIDv7 generation**
  - `UuidV7Factory` produces RFC 9562 UUIDv7 values as `Guid`
  - Works with real or simulated time
  - Configurable counter overflow behavior

- **Hybrid Logical Clock (HLC)**
  - HLC timestamps and utilities to preserve causality in distributed simulations
  - Helpers to witness remote timestamps and generate outbound timestamps

- **Lightweight instrumentation**
  - Counters for timers, advances, and timeouts useful in simulation/test assertions

## Quick start

### Deterministic timers with simulated time

```csharp
var tp = new SimulatedTimeProvider();

var fired = 0;
using var timer = tp.CreateTimer(_ => fired++, null, TimeSpan.FromSeconds(1), Timeout.InfiniteTimeSpan);

tp.Advance(TimeSpan.FromSeconds(1));
// fired == 1
```

### TimeProvider-driven timeouts

```csharp
var tp = new SimulatedTimeProvider();

using var timeout = Timeouts.CreateTimeoutHandle(tp, TimeSpan.FromSeconds(5));

tp.Advance(TimeSpan.FromSeconds(5));
// timeout.Token.IsCancellationRequested == true
```

### UUIDv7 generation

```csharp
var factory = new UuidV7Factory(TimeProvider.System);
var id = factory.NewGuid();
```

## Package

- Target framework: `net10.0`
- License: MIT
- Repository: https://github.com/dexcompiler/Clockworks

## Security considerations

### UUIDv7 time exposure

UUIDv7 values **embed a millisecond-resolution timestamp** by design (RFC 9562). As a result, any UUIDv7 generated by
`UuidV7Factory` can be decoded to reveal an approximate creation time, and ordering/rate information can sometimes be inferred
from sequences of IDs.

If you are issuing identifiers across **untrusted/public boundaries** (URLs, externally-visible resource IDs, third-party logs),
do not treat UUIDv7 as opaque. Common mitigations are:

- Use a random UUID (e.g., UUIDv4) for externally-visible identifiers.
- Keep UUIDv7 as an internal primary key, and expose a separate opaque token externally.
- Wrap/encrypt identifiers for external presentation if you need internal ordering but external opacity.

## Notes on determinism

Clockworks is designed so that advancing simulated scheduler time deterministically drives timers/timeouts.
Wall time can be modified independently for clock-skew/rewind simulations.

## Contributing

Issues and PRs are welcome. Please include tests for behavioral changes.
